
R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(glmm)
Loading required package: trust
Loading required package: mvtnorm
> data(BoothHobert)
> set.seed(1234)
> mod.mcml1<-glmm(y~0+x1,list(y~0+z1),varcomps.names=c("z1"), data=BoothHobert, family.glmm=bernoulli.glmm, m=21, doPQL=TRUE, debug=TRUE, distrib="normal")
> 
> mod.mcml<-mod.mcml1$mod.mcml
> z<-mod.mcml$z[[1]]
> x<-mod.mcml$x
> y<-mod.mcml$y
> 
> stuff<-mod.mcml1$debug
> beta.pql<-stuff$beta.pql
> nu.pql<-stuff$nu.pql
> u.pql<-u.star<-stuff$u.star
> umat<-stuff$umat
> 
> family.glmm<-bernoulli.glmm
> 
> objfun<-glmm:::objfun
> getEk<-glmm:::getEk
> addVecs<-glmm:::addVecs
> 
> ############################################
> #this should be the same as elc
> logfyuk<-function(eta,x,y){
+ 	value<-sum(y*eta)-sum(log(1+exp(eta)))
+ 	Pi<-exp(eta)/(1+exp(eta))
+ 	gradient<-sum(y*x)-sum(x*Pi)
+ 	hessian<-sum(x^2*(-Pi+Pi^2)	)
+ 	list(value=value,gradient=gradient,hessian=hessian)
+ }
> 
> #compare elc and logfyuk for a value of eta
> eta<-rep(2,150)
> this<-.C("elc",as.double(mod.mcml$y),as.double(mod.mcml$x),as.integer(nrow(mod.mcml$x)),as.integer(ncol(mod.mcml$x)),as.double(eta),as.integer(1),value=double(1),gradient=double(ncol(mod.mcml$x)),hessian=double((ncol(mod.mcml$x)^2)))
> that<-logfyuk(eta,mod.mcml$x,mod.mcml$y)
> all.equal(as.numeric(this$value),as.numeric(that$value))
[1] TRUE
> all.equal(as.numeric(this$gradient),as.numeric(that$gradient))
[1] TRUE
> all.equal(as.numeric(this$hessian),as.numeric(that$hessian))
[1] TRUE
> 
> ############################################
> #want to check distRand when we use a normal distribution to get our random effects
> distRandCheck<-function(nu,uvec,muvec){
+ ukmuk<-sum((uvec-muvec)^2)
+ value<--5*log(nu)-ukmuk/(2*nu)
+ gradient<- -5/nu +ukmuk/(2*nu^2)
+ hessian<- 5/(nu^2)-ukmuk/(nu^3)
+ hessian<-as.matrix(hessian)
+ list(value=value,gradient=gradient,hessian=hessian)
+ }
> 
> distRand<-glmm:::distRand
> 
> you<-umat[1,]
> this<-distRandCheck(2,you,u.pql)
> that<-distRand(2,you,mod.mcml$z,u.pql)
> 
> all.equal(this,that)
[1] TRUE
> 
> 
> 
> ###############################################
> #distRandGeneral in R first
> distRandGeneral<-function(uvec,mu,Sigma.inv){
+ 	logDetSigmaInv<-sum(log(eigen(Sigma.inv,symmetric=TRUE)$values))
+ 	umu<-uvec-mu
+ 	piece2<-t(umu)%*%Sigma.inv%*%umu
+ 	as.vector(.5*(logDetSigmaInv-piece2))
+ }
> D.star<-2*diag(10)
> D.star.inv<-.5*diag(10)
> this<-distRandGeneral(you,u.pql,D.star.inv)
> all.equal(this,that$value)
[1] TRUE
> 
> #check distRandGenC
> logdet<-sum(log(eigen(D.star.inv)$values))
> stuff<-.C("distRandGenC",as.double(D.star.inv),as.double(logdet), as.integer(length(you)), as.double(you), as.double(u.pql), double(1))[[6]]
> all.equal(that$value,stuff)
[1] TRUE
> 
> ############################################
> #want to check that the value of objfun is the same for a value of nu and beta
> m<-nrow(umat)
> dbb<-db<-b<-rep(0,m)
> sigsq<-nu<-2
> beta<-6
> Z<-mod.mcml$z[[1]]
> D.star.inv<-.5*diag(10)
> 
> eta.star<-x*beta.pql+as.vector(Z%*%u.star)
> cdouble<-as.vector(bernoulli.glmm()$cpp(eta.star)) #still a vector
> cdouble<-diag(cdouble)
> Sigmuh.inv<- t(Z)%*%cdouble%*%Z+D.star.inv
> Sigmuh<-solve(Sigmuh.inv)
> 
> piece3<-rep(0,3)
> 
> #now go through row by row of umat 
> #ie go through each vector of gen rand eff
> for(k in 1:m){
+ 	uvec<-umat[k,]
+ 	eta<-x*beta+as.vector(Z%*%uvec)
+ 
+ 	piece1<- logfyuk(eta,x,y)$value	
+ 	piece2<- distRandCheck(nu,uvec,rep(0,10))$value
+ 	
+ 	piece3[1]<- distRandGeneral(uvec, rep(0,10),D.star.inv)
+ 	piece3[2]<- distRandGeneral(uvec, u.star, D.star.inv)
+ 	piece3[3]<-distRandGeneral(uvec,u.star,Sigmuh.inv)
+ 
+ 	damax<-max(piece3)
+ 	blah<-sum(exp(piece3-damax)/3)
+ 	lefoo<-damax+log(blah)
+ 	b[k]<-piece1+piece2-lefoo
+ 	}	
> a<-max(b)
> top<-exp(b-a)
> value<-a+log(mean(top))
> #going to compare this against objfun's value
> cache<-new.env(parent = emptyenv())
> objfun<-glmm:::objfun
> that<-objfun(c(beta,nu),nbeta=1,nu.pql=nu.pql,u.star=u.star,mod.mcml=mod.mcml, family.glmm=bernoulli.glmm,cache=cache,distrib="normal",gamm=15,umat=umat, p1=1/3,p2=1/3,p3=1/3,D.star=D.star,Sigmuh=Sigmuh)
> all.equal(value,that$value)	
[1] TRUE
> #Given generated random effects, the value of the objective function is correct.
> #This plus the test of finite diffs for objfun should be enough.
> 
> 
> 
> 
> 
> proc.time()
   user  system elapsed 
  1.114   0.039   1.137 
