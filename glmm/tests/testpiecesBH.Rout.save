
R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(glmm)
Loading required package: trust
Loading required package: mvtnorm
Loading required package: Matrix
Loading required package: parallel
Loading required package: doParallel
Loading required package: foreach
Loading required package: iterators
> data(BoothHobert)
> clust <- makeCluster(2)
> set.seed(1234)
<<<<<<< HEAD
> mod.mcml1<-glmm(y~0+x1,list(y~0+z1),varcomps.names=c("z1"), data=BoothHobert, family.glmm=bernoulli.glmm, m=21, 
+                 doPQL=TRUE, debug=TRUE, cores=1)
=======
> mod.mcml1<-glmm(y~0+x1,list(y~0+z1),varcomps.names=c("z1"), data=BoothHobert, family.glmm=bernoulli.glmm, m=21, doPQL=TRUE, debug=TRUE, cluster=clust)
>>>>>>> 8a3d432ba716ecf769f1dc34b1aed5a506eb532a
> 
> mod.mcml<-mod.mcml1$mod.mcml
> z<-mod.mcml$z[[1]]
> x<-mod.mcml$x
> y<-mod.mcml$y
> 
> stuff<-mod.mcml1$debug
> beta.pql<-stuff$beta.pql
> nu.pql<-stuff$nu.pql
> u.pql<-u.star<-stuff$u.star
> umat<-stuff$umat
> m1<-stuff$m1
> 
> family.glmm<-bernoulli.glmm
> 
> objfun<-glmm:::objfun
> getEk<-glmm:::getEk
> addVecs<-glmm:::addVecs
> 
> ############################################
> #this should be the same as elc
> logfyuk<-function(eta,x,y){
+ 	value<-sum(y*eta)-sum(log(1+exp(eta)))
+ 	Pi<-exp(eta)/(1+exp(eta))
+ 	gradient<-sum(y*x)-sum(x*Pi)
+ 	hessian<-sum(x^2*(-Pi+Pi^2)	)
+ 	list(value=value,gradient=gradient,hessian=hessian)
+ }
> 
> #compare elc and logfyuk for a value of eta
> eta<-rep(2,150)
> this<-.C(glmm:::C_elc,as.double(mod.mcml$y), as.double(mod.mcml$x), as.integer(nrow(mod.mcml$x)), as.integer(ncol(mod.mcml$x)), as.double(eta), as.integer(1), as.integer(1), value=double(1), gradient=double(ncol(mod.mcml$x)), hessian=double((ncol(mod.mcml$x)^2)))
> that<-logfyuk(eta,mod.mcml$x,mod.mcml$y)
> all.equal(as.numeric(this$value),as.numeric(that$value))
[1] TRUE
> all.equal(as.numeric(this$gradient),as.numeric(that$gradient))
[1] TRUE
> all.equal(as.numeric(this$hessian),as.numeric(that$hessian))
[1] TRUE
> 
> #compare elval to logfyuk
> this<-.C(glmm:::C_elval, as.double(mod.mcml$y), as.integer(nrow(mod.mcml$x)), as.integer(ncol(mod.mcml$x)), as.double(eta), as.integer(1), as.integer(1), value=double(1))
> all.equal(as.numeric(this$value),as.numeric(that$value))
[1] TRUE
> 
> #compare elGH to logfyuk
> this<-.C(glmm:::C_elGH, as.double(mod.mcml$y), as.double(mod.mcml$x), as.integer(nrow(mod.mcml$x)), as.integer(ncol(mod.mcml$x)), as.double(eta), as.integer(1), as.integer(1), gradient=double(ncol(mod.mcml$x)), hessian=double((ncol(mod.mcml$x)^2)))
> all.equal(as.numeric(this$gradient),as.numeric(that$gradient))
[1] TRUE
> all.equal(as.numeric(this$hessian),as.numeric(that$hessian))
[1] TRUE
> 
> ############################################
> #want to check distRand when we use a normal distribution to get our random effects
> #check written for BH
> distRandCheck<-function(nu,uvec,muvec){
+ 	ukmuk<-sum((uvec-muvec)^2)
+ 	value<- -length(uvec)*.5*log(2*pi)-5*log(nu)-ukmuk/(2*nu)
+ 	gradient<- -5/nu +ukmuk/(2*nu^2)
+ 	hessian<- 5/(nu^2)-ukmuk/(nu^3)
+ 	hessian<-as.matrix(hessian)
+ 	list(value=value,gradient=gradient,hessian=hessian)
+ }
> 
> #function written originally in R
> distRand <-
+ function(nu,U,z.list,mu){
+ 	# T=number variance components
+ 	T<-length(z.list)
+ 	
+ 	#nrandom is q_t
+ 	nrand<-lapply(z.list,ncol)
+ 	nrandom<-unlist(nrand)
+ 	totnrandom<-sum(nrandom)
+ 	
+ 	mu.list<-U.list<-NULL
+ 	if(T==1) {
+ 		U.list[[1]]<-U
+ 		mu.list[[1]]<-mu
+ 		}
+ 
+ 	if(T>1){
+ 		U.list[[1]]<-U[1:nrandom[1]] 
+ 		mu.list[[1]]<-mu[1:nrandom[1]]
+ 		for(t in 2:T){
+ 			thing1<-sum(nrandom[1:t-1])+1
+ 			thing2<-sum(nrandom[1:t])
+ 			U.list[[t]]<-U[thing1:thing2]
+ 			mu.list[[t]]<-mu[thing1:thing2]
+ 		}
+ 	}
+ 	
+ 	val<-gradient<-Hessian<-rep(0,T)
+ 	
+ 	#for each variance component
+ 	for(t in 1:T){
+ 		you<-as.vector(U.list[[t]])
+ 		mew<-as.vector(mu.list[[t]])
+ 		Umu<-(you-mew)%*%(you-mew)
+ 		val[t]<--length(you)*.5*log(2*pi)+ as.numeric(-.5*nrandom[t]*log(nu[t])-Umu/(2*nu[t]))
+ 		
+ 		gradient[t]<- -nrandom[t]/(2*nu[t])+Umu/(2*(nu[t])^2)
+ 		
+ 		Hessian[t]<- nrandom[t]/(2*(nu[t])^2)- Umu/((nu[t])^3)
+ 		
+ 	}
+ 		
+ 	value<-sum(val)
+ 	if(T>1) hessian<-diag(Hessian)
+ 	if(T==1) hessian<-matrix(Hessian,nrow=1,ncol=1)
+ 	
+ 	list(value=value,gradient=gradient,hessian=hessian)		
+ }
> 
> 
> you<-umat[1,]
> this<-distRandCheck(2,you,u.pql)
> that<-distRand(2,you,mod.mcml$z,u.pql)
> 
> all.equal(this,that)
[1] TRUE
> 
> #use finite diffs to make sure distRandCheck (and distRand) have correct derivs
> del<-10^(-9)
> thisdel<-distRandCheck(2+del,you,u.pql)
> firstthing<-thisdel$value-this$value
> secondthing<-as.vector(this$gradient%*%del)
> all.equal(firstthing,secondthing)
[1] TRUE
<<<<<<< HEAD
> #firstthing
> #secondthing
> #firstthing-secondthing
=======
> firstthing
[1] -1.285952e-08
> secondthing
[1] -1.285952e-08
> firstthing-secondthing
[1] 4.898647e-16
>>>>>>> 8a3d432ba716ecf769f1dc34b1aed5a506eb532a
> 
> #compare the gradient and hessian of the C functions by using these functions
> #(the value is checked in distRandGeneral)
> 
> mynu<-2
> mymu<-rep(0,10)
> T<-1
> nrandom<-10
> meow<-c(0,10)
> set.seed(1234)
> myyou<-rnorm(10)
> hohum<-.C(glmm:::C_distRand3C,as.double(mynu), as.double(mymu), as.integer(T), as.integer(nrandom), as.integer(meow), as.double(myyou), double(T), double(T^2)) 
> drcheck<-distRandCheck(mynu,myyou,mymu)
> all.equal(drcheck$gradient,hohum[[7]])
[1] TRUE
> all.equal(drcheck$hessian,matrix(hohum[[8]],nrow=T,byrow=F))
[1] TRUE
> 
> ###############################################
> #distRandGeneral in R first
> distRandGeneral<-function(uvec,mu,Sigma.inv){
+ 	logDetSigmaInv<-sum(log(eigen(Sigma.inv,symmetric=TRUE)$values))
+ 	umu<-uvec-mu
+ 	piece2<-t(umu)%*%Sigma.inv%*%umu
+ 	out<-as.vector(.5*(logDetSigmaInv-piece2))
+ 	const<-length(uvec)*.5*log(2*pi)
+ 	out<-out-const
+ 	out
+ }
> 
> D.star<-2*diag(10)
> D.star.inv<-.5*diag(10)
> A.star<-sqrt(2)*diag(10)
> this<-distRandGeneral(you,u.pql,D.star.inv)
> all.equal(this,that$value)
[1] TRUE
> 
> #check distRandGenC
> logdet<-sum(log(eigen(D.star.inv)$values))
> stuff<-.C(glmm:::C_distRandGenC,as.double(D.star.inv),as.double(logdet), as.integer(length(you)), as.double(you), as.double(u.pql), double(1))[[6]]
> all.equal(that$value,stuff)
[1] TRUE
> 
> 
> ############################################
> #want to check that the value of objfun is the same for a value of nu and beta
> vars <- new.env(parent = emptyenv())
> debug<-mod.mcml1$debug
> 
> vars$m1 <- debug$m1
> m2 <- debug$m2
> m3 <- debug$m3
> 
> vars$zeta <- 5
> 
> vars$cl <- mod.mcml1$cluster
> registerDoParallel(vars$cl)                   #making cluster usable with foreach
> vars$no_cores <- length(vars$cl)
> 
> vars$mod.mcml<-mod.mcml1$mod.mcml
> 
> vars$nu.pql <- debug$nu.pql
> 
> getEk<-glmm:::getEk
> addVecs<-glmm:::addVecs
> genRand<-glmm:::genRand
> 
> nrand<-lapply(vars$mod.mcml$z,ncol)
> nrandom<-unlist(nrand)
> q<-sum(nrandom)
> totnrandom<-sum(nrandom)
> s.pql<-rep(0,totnrandom)
> if(q!=length(s.pql)) stop("Can't happen. Number of random effects returned by PQL must match number of random effects specified by model.")
> eek<-getEk(vars$mod.mcml$z)
> sigma.pql<-rep(1,length(vars$mod.mcml$z))
> #if any of the variance components are too close to 0, make them bigger:
> if(any(sigma.pql<10^-3)){
+   theseguys<-which(sigma.pql<10^-3)
+   sigma.pql[theseguys]<-10^-3
+ }
> Aks<-Map("*",eek,sigma.pql)
> A.star<-addVecs(Aks) #at this point still a vector
> vars$D.star<-A.star*A.star #still a vector
> vars$u.star<-A.star*s.pql 
> Dstarinvdiag<-1/vars$D.star
> Dstarnotsparse<-diag(vars$D.star)
> vars$D.star<-Diagonal(length(vars$u.star),vars$D.star)
> 
> vars$family.glmm<-mod.mcml1$family.glmm
> 
> vars$ntrials<-1
> 
> beta.pql <- debug$beta.pql
> 
> simulate <- function(vars, Dstarnotsparse, m2, m3, beta.pql, D.star.inv){
+   #generate m1 from t(0,D*)
+   if(vars$m1>0) genData<-rmvt(ceiling(vars$m1/vars$no_cores),sigma=Dstarnotsparse,df=vars$zeta,type=c("shifted"))
+   if(vars$m1==0) genData<-NULL		
+   
+   #generate m2 from N(u*,D*)
+   if(m2>0) genData2<-genRand(vars$u.star,vars$D.star,ceiling(m2/vars$no_cores))
+   if(m2==0) genData2<-NULL
+   
+   
+   #generate m3 from N(u*,(Z'c''(Xbeta*+zu*)Z+D*^{-1})^-1)
+   if(m3>0){
+     Z=do.call(cbind,vars$mod.mcml$z)
+     eta.star<-as.vector(vars$mod.mcml$x%*%beta.pql+Z%*%vars$u.star)
+     if(vars$family.glmm$family.glmm=="bernoulli.glmm") {cdouble<-vars$family.glmm$cpp(eta.star)}
+     if(vars$family.glmm$family.glmm=="poisson.glmm"){cdouble<-vars$family.glmm$cpp(eta.star)}
+     if(vars$family.glmm$family.glmm=="binomial.glmm"){cdouble<-vars$family.glmm$cpp(eta.star, vars$ntrials)}
+     #still a vector
+     cdouble<-Diagonal(length(cdouble),cdouble)
+     Sigmuh.inv<- t(Z)%*%cdouble%*%Z+D.star.inv
+     Sigmuh<-solve(Sigmuh.inv)
+     genData3<-genRand(vars$u.star,Sigmuh,ceiling(m3/vars$no_cores))
+   }
+   if(m3==0) genData3<-NULL
+   
+   #	#these are from distribution based on data
+   #	if(distrib=="tee")genData<-genRand(sigma.gen,s.pql,mod.mcml$z,m1,distrib="tee",gamm)
+   #	if(distrib=="normal")genData<-genRand(sigma.pql,s.pql,mod.mcml$z,m1,distrib="normal",gamm)
+   #	#these are from standard normal
+   #	ones<-rep(1,length(sigma.pql))
+   #	zeros<-rep(0,length(s.pql))
+   #	genData2<-genRand(ones,zeros,mod.mcml$z,m2,distrib="normal",gamm)
+   
+   umat<-rbind(genData,genData2,genData3)
+   m <- nrow(umat)
+   list(umat=umat, m=m, Sigmuh.inv=Sigmuh.inv)
+ }
> 
> clusterSetRNGStream(vars$cl, 1234)
> 
> clusterExport(vars$cl, c("vars", "Dstarnotsparse", "m2", "m3", "beta.pql", "D.star.inv", "simulate", "genRand"), envir = environment())     #installing variables on each core
> clusterEvalQ(vars$cl, umatparams <- simulate(vars=vars, Dstarnotsparse=Dstarnotsparse, m2=m2, m3=m3, beta.pql=beta.pql, D.star.inv=D.star.inv))
[[1]]
[[1]]$umat
             [,1]        [,2]       [,3]        [,4]       [,5]         [,6]
 [1,] -0.04886222 -0.56494445  0.1103789  0.02663283  0.6660776 -0.060233489
 [2,] -1.46045633 -1.06310795  0.5728887 -0.46142510 -0.6234585 -1.620467114
 [3,] -0.24955979  0.49911887  1.1536682  1.04038745  0.7368057 -0.007008433
 [4,] -0.55702951  1.08571570 -1.7723186  1.00262043 -1.4582470 -0.697473055
 [5,] -0.11883094  0.77098127 -1.1585584  0.71647275  0.3278247 -0.102063613
 [6,]  0.70693407 -2.46334700  1.1443436  0.50845641  0.5680107 -0.504004351
 [7,] -0.27802398  1.15074784 -0.7508844 -0.46636130  2.1445229 -0.007694807
 [8,]  1.06051695  1.78075593  0.7677657 -0.07599083 -1.3078217  0.540051131
 [9,] -0.80021372  0.08897295 -1.5801268  1.13916962 -0.4137225 -1.100155206
[10,] -0.33297477  0.51054230  1.0912739  1.00763803  0.4816751  0.563323492
[11,] -1.05183159  0.67501961  0.5123368  0.12353286 -0.6278547 -1.119346567
             [,7]        [,8]        [,9]      [,10]
 [1,]  0.06839782  0.75949548 -0.08640101  0.2615504
 [2,] -0.77045745  0.82536136 -2.20605392  0.1924099
 [3,] -1.13719153  0.39237306  0.22005069 -0.5927040
 [4,] -0.77661355 -0.06342377 -2.51202833  0.8197113
 [5,]  0.00967639 -0.53338826  1.04605264 -0.3404673
 [6,] -1.32357419 -1.57745175 -0.05226397  0.7045138
 [7,]  1.51366437  0.02234099 -0.62819088  0.4076956
 [8,]  0.16078356  1.26088554 -0.67654259 -0.6381364
 [9,] -0.34092443 -0.57542490  2.48477042 -0.8843389
[10,] -0.15940359  0.18553202  0.62944090 -1.5415134
[11,]  0.76528805  0.32684262 -0.06715563  0.2829974

[[1]]$m
[1] 11

[[1]]$Sigmuh.inv
10 x 10 sparse Matrix of class "dgCMatrix"
   [[ suppressing 10 column names 'z11', 'z12', 'z13' ... ]]
                                                                            
z11  1.677939 .        .        .        .        .        .        .       
z12  .        1.677939 .        .        .        .        .        .       
z13  .        .        1.677939 .        .        .        .        .       
z14  .        .        .        1.677939 .        .        .        .       
z15  .        .        .        .        1.677939 .        .        .       
z16  .        .        .        .        .        1.677939 .        .       
z17  .        .        .        .        .        .        1.677939 .       
z18  .        .        .        .        .        .        .        1.677939
z19  .        .        .        .        .        .        .        .       
z110 .        .        .        .        .        .        .        .       
                      
z11  .        .       
z12  .        .       
z13  .        .       
z14  .        .       
z15  .        .       
z16  .        .       
z17  .        .       
z18  .        .       
z19  1.677939 .       
z110 .        1.677939


[[2]]
[[2]]$umat
             [,1]        [,2]       [,3]        [,4]        [,5]         [,6]
 [1,] -0.25488395  1.32825566  0.1197497 -0.50316888 -1.87636107  0.001471004
 [2,] -0.47652254  0.04066878 -0.5720551  0.09081624  0.58745514 -0.765456628
 [3,] -0.22000637  0.66449683 -1.4341066 -1.47793223  0.37094359 -0.771733328
 [4,] -0.06090763 -0.01409293 -0.4248234 -0.32568036 -0.74336777 -0.595465289
 [5,]  8.06722735 -3.45039754  5.9353182  2.17378785  1.65735642 -3.286115293
 [6,]  1.38614027  0.57943201 -0.6785026  0.76339175  0.03940943 -0.435469323
 [7,]  0.36484879  0.81117608 -1.1432330 -0.40674860  0.17569112 -0.412977530
 [8,]  0.27975593  0.78660545  0.3927324 -0.53076690 -2.41445911  0.640044229
 [9,] -0.94368251 -1.33568937 -0.7293568 -1.28664960 -0.35177326  0.041760812
[10,] -0.53633850 -0.13423021  1.0622050 -0.17739431 -0.86250233  0.153202293
[11,]  0.07836025  0.27256662  0.1880322 -0.39352579  0.05949990  0.463429792
             [,7]         [,8]        [,9]      [,10]
 [1,] -0.98443770 -0.786381605  1.56209213  0.0925287
 [2,]  0.05593231  1.258516055  0.56123770  0.4034467
 [3,] -0.45483820 -0.151031412 -0.39024479  0.1439703
 [4,] -0.81932199  0.361336426 -0.38146665 -2.3253083
 [5,] -0.84390861 -1.182972553  1.65918722  2.2189959
 [6,]  0.51322193 -0.622450444  0.73884121  1.0635060
 [7,]  0.26738190 -0.975299871  1.36658734  0.7360706
 [8,]  0.48225179 -0.431623912 -0.91296470 -2.5864239
 [9,]  1.43726673 -1.652903353 -0.28700011  0.6247459
[10,]  0.09138369 -0.007242977  1.06893131  1.3419046
[11,]  0.05315965 -0.328003671 -0.08999378  1.2164915

[[2]]$m
[1] 11

[[2]]$Sigmuh.inv
10 x 10 sparse Matrix of class "dgCMatrix"
   [[ suppressing 10 column names 'z11', 'z12', 'z13' ... ]]
                                                                            
z11  1.677939 .        .        .        .        .        .        .       
z12  .        1.677939 .        .        .        .        .        .       
z13  .        .        1.677939 .        .        .        .        .       
z14  .        .        .        1.677939 .        .        .        .       
z15  .        .        .        .        1.677939 .        .        .       
z16  .        .        .        .        .        1.677939 .        .       
z17  .        .        .        .        .        .        1.677939 .       
z18  .        .        .        .        .        .        .        1.677939
z19  .        .        .        .        .        .        .        .       
z110 .        .        .        .        .        .        .        .       
                      
z11  .        .       
z12  .        .       
z13  .        .       
z14  .        .       
z15  .        .       
z16  .        .       
z17  .        .       
z18  .        .       
z19  1.677939 .       
z110 .        1.677939


> 
> vars$nbeta <- 1
> 
> vars$p1=vars$p2=vars$p3=1/3
> 
> objfun<-glmm:::objfun
> 
> umats <- clusterEvalQ(vars$cl, umatparams$umat)
> umat <- Reduce(rbind, umats)
> 
> Sigmuh.invs <- clusterEvalQ(vars$cl, umatparams$Sigmuh.inv)
> Sigmuh.inv <- Sigmuh.invs[[1]]
> Sigmuh <- solve(Sigmuh.inv)
> 
> ms <- clusterEvalQ(vars$cl, umatparams$m)
> m <- ms[[1]]
> 
> dbb<-db<-b<-rep(0,m)
> sigsq<-nu<-2
> beta<-6
> Z<-vars$mod.mcml$z[[1]]
> D.star.inv<-.5*diag(10)
> A<-sqrt(2)*diag(10)
> D<-2*diag(10)
> D.inv<-.5*diag(10)
> 
> eta.star<-x*beta.pql+as.vector(Z%*%u.star)
> cdouble<-as.vector(bernoulli.glmm()$cpp(eta.star)) #still a vector
> cdouble<-diag(cdouble)
> 
> piece3<-rep(0,3)
> 
> #calculate objfun's value for comparison
> cache<-new.env(parent = emptyenv())
> 
> that<-objfun(c(beta,nu), cache=cache,vars=vars)
> 
> #get t stuff ready
> tconstant<-glmm:::tconstant
> zeta<-5
> tconst<-tconstant(zeta,10,diag(D.star.inv))
> tdist2<-function(tconst,u, Dstarinv,zeta,myq){
+ 	inside<-1+t(u)%*%Dstarinv%*%u/zeta
+ 	logft<-tconst - ((zeta+myq)/2)*log(inside)
+ 	as.vector(logft)
+ }
> 
> 
> #now go through row by row of umat 
> #ie go through each vector of gen rand eff
> for(k in 1:m){
+ 	uvec<-umat[k,]
+ 	eta<-x*beta+as.vector(Z%*%uvec)
+ 
+ 	piece1<- logfyuk(eta,x,y)$value	
+ 	piece2<- distRandCheck(nu,uvec,rep(0,10))$value
+ 	
+ 	piece3[1]<-tdist2(tconst,uvec,D.star.inv,zeta,10)
+ 	piece3[2]<- distRandGeneral(uvec, u.star, D.star.inv)
+ 	piece3[3]<-distRandGeneral(uvec,u.star,Sigmuh.inv)
+ 
+ 	damax<-max(piece3)
+ 	blah<-sum(exp(piece3-damax)/3)
+ 	lefoo<-damax+log(blah)
+ 	b[k]<-piece1+piece2-lefoo
+ 	}	
> a<-max(b)
> top<-exp(b-a)
> value<-a+log(mean(top))
> 
> all.equal(value,that$value)	
[1] "Mean relative difference: 0.03202091"
> #Given generated random effects, the value of the objective function is correct.
> #This plus the test of finite diffs for objfun should be enough.
> 
> stopCluster(clust)
> 
> 
> 
> proc.time()
   user  system elapsed 
<<<<<<< HEAD
  2.092   0.196  15.281 
=======
  5.697   0.440   9.125 
>>>>>>> 8a3d432ba716ecf769f1dc34b1aed5a506eb532a
