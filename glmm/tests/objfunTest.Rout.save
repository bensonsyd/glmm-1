
R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #check objfun using finite differences
> library(glmm)
Loading required package: trust
Loading required package: mvtnorm
Loading required package: Matrix
Loading required package: parallel
Loading required package: doParallel
Loading required package: foreach
Loading required package: iterators
> data(BoothHobert)
> clust <- makeCluster(2)
> set.seed(1234)
> out<-glmm(y~0+x1,list(y~0+z1),varcomps.names=c("z1"),data=BoothHobert,
+ family.glmm=bernoulli.glmm,m=50,doPQL=FALSE,debug=TRUE, cluster=clust)
> 
> vars <- new.env(parent = emptyenv())
> debug<-out$debug
> 
> vars$m1 <- debug$m1
> m2 <- debug$m2
> m3 <- debug$m3
> 
> vars$zeta <- 5
> 
> vars$cl <- out$cluster
> registerDoParallel(vars$cl)                   #making cluster usable with foreach
> vars$no_cores <- length(vars$cl)
> 
> vars$mod.mcml<-out$mod.mcml
> 
> vars$nu.pql <- debug$nu.pql
> 
> getEk<-glmm:::getEk
> addVecs<-glmm:::addVecs
> genRand<-glmm:::genRand
> 
> nrand<-lapply(vars$mod.mcml$z,ncol)
> nrandom<-unlist(nrand)
> q<-sum(nrandom)
> totnrandom<-sum(nrandom)
> s.pql<-rep(0,totnrandom)
> if(q!=length(s.pql)) stop("Can't happen. Number of random effects returned by PQL must match number of random effects specified by model.")
> eek<-getEk(vars$mod.mcml$z)
> sigma.pql<-rep(1,length(vars$mod.mcml$z))
> #if any of the variance components are too close to 0, make them bigger:
> if(any(sigma.pql<10^-3)){
+   theseguys<-which(sigma.pql<10^-3)
+   sigma.pql[theseguys]<-10^-3
+ }
> Aks<-Map("*",eek,sigma.pql)
> A.star<-addVecs(Aks) #at this point still a vector
> vars$D.star<-A.star*A.star #still a vector
> vars$u.star<-A.star*s.pql 
> Dstarinvdiag<-1/vars$D.star
> Dstarnotsparse<-diag(vars$D.star)
> D.star.inv<-Diagonal(length(vars$u.star),Dstarinvdiag)
> vars$D.star<-Diagonal(length(vars$u.star),vars$D.star)
> 
> vars$family.glmm<-out$family.glmm
> 
> vars$ntrials<-1
> 
> beta.pql <- debug$beta.pql
> 
> simulate <- function(vars, Dstarnotsparse, m2, m3, beta.pql, D.star.inv){
+   #generate m1 from t(0,D*)
+   if(vars$m1>0) genData<-rmvt(ceiling(vars$m1/vars$no_cores),sigma=Dstarnotsparse,df=vars$zeta,type=c("shifted"))
+   if(vars$m1==0) genData<-NULL		
+   
+   #generate m2 from N(u*,D*)
+   if(m2>0) genData2<-genRand(vars$u.star,vars$D.star,ceiling(m2/vars$no_cores))
+   if(m2==0) genData2<-NULL
+   
+   
+   #generate m3 from N(u*,(Z'c''(Xbeta*+zu*)Z+D*^{-1})^-1)
+   if(m3>0){
+     Z=do.call(cbind,vars$mod.mcml$z)
+     eta.star<-as.vector(vars$mod.mcml$x%*%beta.pql+Z%*%vars$u.star)
+     if(vars$family.glmm$family.glmm=="bernoulli.glmm") {cdouble<-vars$family.glmm$cpp(eta.star)}
+     if(vars$family.glmm$family.glmm=="poisson.glmm"){cdouble<-vars$family.glmm$cpp(eta.star)}
+     if(vars$family.glmm$family.glmm=="binomial.glmm"){cdouble<-vars$family.glmm$cpp(eta.star, vars$ntrials)}
+     #still a vector
+     cdouble<-Diagonal(length(cdouble),cdouble)
+     Sigmuh.inv<- t(Z)%*%cdouble%*%Z+D.star.inv
+     Sigmuh<-solve(Sigmuh.inv)
+     genData3<-genRand(vars$u.star,Sigmuh,ceiling(m3/vars$no_cores))
+   }
+   if(m3==0) genData3<-NULL
+   
+   #	#these are from distribution based on data
+   #	if(distrib=="tee")genData<-genRand(sigma.gen,s.pql,mod.mcml$z,m1,distrib="tee",gamm)
+   #	if(distrib=="normal")genData<-genRand(sigma.pql,s.pql,mod.mcml$z,m1,distrib="normal",gamm)
+   #	#these are from standard normal
+   #	ones<-rep(1,length(sigma.pql))
+   #	zeros<-rep(0,length(s.pql))
+   #	genData2<-genRand(ones,zeros,mod.mcml$z,m2,distrib="normal",gamm)
+   
+   umat<-rbind(genData,genData2,genData3)
+   m <- nrow(umat)
+   list(umat=umat, m=m, Sigmuh.inv=Sigmuh.inv)
+ }
> 
> clusterSetRNGStream(vars$cl, 1234)
> 
> clusterExport(vars$cl, c("vars", "Dstarnotsparse", "m2", "m3", "beta.pql", "D.star.inv", "simulate", "genRand"), envir = environment())     #installing variables on each core
> clusterEvalQ(vars$cl, umatparams <- simulate(vars=vars, Dstarnotsparse=Dstarnotsparse, m2=m2, m3=m3, beta.pql=beta.pql, D.star.inv=D.star.inv))
[[1]]
[[1]]$umat
              [,1]        [,2]        [,3]        [,4]        [,5]         [,6]
 [1,] -0.080430052 -0.92993136  0.18169000  0.04383918  1.09640236 -0.099147820
 [2,] -1.938026615 -1.41074503  0.76022367 -0.61231144 -0.82732984 -2.150361049
 [3,] -0.275440766  0.55088074  1.27331105  1.14828239  0.81321724 -0.007735253
 [4,] -0.482828948  0.94109011 -1.53623229  0.86906377 -1.26399742 -0.604564343
 [5,] -0.176867736  1.14752701 -1.72439607  1.06639664  0.48793369 -0.151911280
 [6,]  1.382713063  0.15381095  0.63048260  0.47050546  0.93726337  0.622742255
 [7,] -0.398328563 -1.04605725 -1.24670370 -0.04130566  0.55679674 -0.219730035
 [8,] -0.014190594  2.79146681  0.04120076 -1.15849591  0.75186326  1.955782233
 [9,]  0.584560463  0.17403484  1.36480380 -0.73230113 -0.69072958 -0.866164839
[10,] -1.293819677 -0.40093865 -0.67671911  2.92217393 -1.04001241 -0.507246658
[11,]  0.505020487 -0.14290559  0.16632978  0.56429486 -1.38196944 -0.942968841
[12,] -1.220994840  0.83478414  0.35652332 -0.07325406  0.30869646 -0.579182636
[13,]  0.333095119 -1.07058570 -0.24420998 -0.61060639  0.18761548  1.026208715
[14,]  0.223998009  1.06158975 -0.80111820  1.26070182  1.05942449 -0.384883671
[15,] -0.224512069  0.48288230 -0.22537055  0.72204311  0.92511799  0.084875255
[16,] -1.019874182 -0.25978789 -0.10586182 -0.18094593  2.05383178 -1.720975343
[17,]  0.669475088  0.38301735 -0.90469467  1.64141951  0.29138519  2.506460910
[18,] -0.919196331 -0.48393544  0.18864890  2.16899875 -0.57341693  0.212844692
[19,]  0.489276598  0.21426774 -0.58595975 -0.26751591 -1.11042455  0.551162569
[20,] -1.924581033 -0.17563772  0.15678533  2.06839874  0.04932767 -0.258244021
[21,] -0.005257399  0.12003202  0.45032345 -0.56535954  0.09449962 -0.539236047
[22,]  0.490290955  0.08712523  0.31082070  0.01627887 -0.33346110  0.224602585
[23,]  0.449331411 -0.60015204  0.31840836 -0.27121523  0.01387721  0.049100778
[24,]  0.264947537  0.05074177  0.56230656  0.27183760  0.16608116 -0.337254725
[25,]  0.076141517 -0.11727009 -0.78030609 -0.14120489  0.25336521 -0.458736624
[26,]  0.113758627 -0.31265039  0.43360059 -0.19654820 -0.29638028  0.122966645
             [,7]        [,8]        [,9]       [,10]
 [1,]  0.11258678  1.25017365 -0.14222108  0.43052710
 [2,] -1.02239760  1.09525513 -2.92743516  0.25532809
 [3,] -1.25512569  0.43306470  0.24287138 -0.65417124
 [4,] -0.67316272 -0.05497524 -2.17740706  0.71051953
 [5,]  0.01440232 -0.79389403  1.55694268 -0.50675093
 [6,] -2.16997644  1.00805879  0.44790216  0.50036391
 [7,]  0.90946781 -0.59344467 -0.36857822  1.69487570
 [8,]  3.28403124  1.41589674 -0.14014063 -2.41185627
 [9,]  0.09630582 -1.71035591  1.23305643 -0.44782024
[10,]  0.77774925  1.66242339  1.53501429  0.73377362
[11,]  0.60515625  0.45931087  0.11074742 -0.56287284
[12,] -1.93821146  1.82375785  2.02532969 -1.53269329
[13,]  0.81124792 -0.66897527 -0.59685323 -1.17627835
[14,] -1.71606777 -1.78841483 -1.57955331 -0.53508854
[15,] -0.13018344  0.04176473  0.31306244 -2.01660522
[16,]  0.22433694 -1.70503654  1.49696569 -0.25567018
[17,]  0.42985569 -0.22552813  0.14481627  0.17168110
[18,] -0.55123930 -0.06267739  0.01762903 -1.43220427
[19,]  0.86931577 -0.21539829  0.29389132  0.53139232
[20,]  1.54277830  0.89341913 -0.30550576 -1.17997038
[21,]  0.40461112  0.16873322 -0.83226037 -1.03178261
[22,] -0.01965185  0.64748963  0.35022227  0.33693456
[23,]  0.86987652 -0.36452379 -0.49273983  0.26188544
[24,] -0.44575309 -0.10141838 -0.18477577 -0.12493103
[25,]  0.38885263  0.08204266 -0.32123899  0.34284037
[26,]  0.40974406 -0.03481506 -0.32574940  0.08952478

[[1]]$m
[1] 26

[[1]]$Sigmuh.inv
10 x 10 sparse Matrix of class "dgCMatrix"
   [[ suppressing 10 column names 'z11', 'z12', 'z13' ... ]]
                                                      
z11  4.75 .    .    .    .    .    .    .    .    .   
z12  .    4.75 .    .    .    .    .    .    .    .   
z13  .    .    4.75 .    .    .    .    .    .    .   
z14  .    .    .    4.75 .    .    .    .    .    .   
z15  .    .    .    .    4.75 .    .    .    .    .   
z16  .    .    .    .    .    4.75 .    .    .    .   
z17  .    .    .    .    .    .    4.75 .    .    .   
z18  .    .    .    .    .    .    .    4.75 .    .   
z19  .    .    .    .    .    .    .    .    4.75 .   
z110 .    .    .    .    .    .    .    .    .    4.75


[[2]]
[[2]]$umat
             [,1]        [,2]        [,3]        [,4]        [,5]         [,6]
 [1,] -0.19332953  1.00748222  0.09083020 -0.38165371 -1.42322030  0.001115757
 [2,] -0.94951901  0.08103662 -1.13987724  0.18096048  1.17056335 -1.525249197
 [3,] -0.26053479  0.78690695 -1.69829023 -1.75018915  0.43927687 -0.913897994
 [4,] -0.06232627 -0.01442118 -0.43471821 -0.33326599 -0.76068205 -0.609334667
 [5,]  1.93148888 -0.82610843  1.42105840  0.52045726  0.39681112 -0.786775292
 [6,] -0.19293995  2.76489862  1.69182847 -0.47263070  1.59165272  1.811598446
 [7,] -0.12519951  0.28375029 -1.37555289  0.33704357  0.48374437 -0.765277684
 [8,] -0.89416794  0.24919193  1.19267864  0.48554503  0.26305977 -0.495714317
 [9,]  0.27317816  0.11496344  0.52647266 -0.67247752  0.37387063 -0.579611950
[10,] -0.17968068  0.89521810  0.44052909  0.05205901 -0.89035208  0.941720358
[11,]  0.10566414 -1.14887464 -0.68211775 -1.25382724  0.40122880  0.799308819
[12,] -0.42852243  1.86055332  1.47988742  0.16748631 -0.22839809  0.277791932
[13,]  0.02492949 -1.17644448  1.14036389  2.28512706 -1.02570264  2.127530523
[14,] -0.27411446 -0.57388170  1.68973815 -0.80020552 -0.13566938  1.305879033
[15,] -0.31327050 -0.20579173  1.14431235  1.25686239 -1.03030180  1.494385785
[16,] -0.35780154 -1.55290054 -0.23351012  1.56946820 -0.10710520  1.063196843
[17,]  0.55719353  0.83841169 -0.50637583  1.30193046 -0.98574790  0.103626985
[18,]  1.04769344 -1.10279862  0.71867121 -0.19500984  1.14489445  0.546410302
[19,] -0.61293403  0.85112485  0.82242868  0.40031030 -1.03623247 -1.056336922
[20,] -0.36318213 -0.46408314  0.23744877 -0.47549996 -0.89933004  0.259350251
[21,] -0.16554792 -0.03999115 -0.25511474 -0.17649206  0.11380410  0.819865961
[22,] -0.11158500 -0.27402258 -0.87627273 -0.39812842 -0.19915596  0.356033084
[23,]  0.39537799  0.68964685 -0.51895176 -0.39771249 -0.25555045  0.265788960
[24,]  1.03415663  0.58853658 -0.07459787  0.30066437  0.34747208 -0.008380929
[25,] -0.14830466  0.21807610  0.74219350  0.34653436  0.03415010 -0.313968782
[26,] -0.27833310  0.35483858 -1.01021759 -0.47741516 -0.04157191 -0.407978805
             [,7]         [,8]        [,9]       [,10]
 [1,] -0.74669622 -0.596470627  1.18484724  0.07018304
 [2,]  0.11145074  2.507719616  1.11832247  0.80390810
 [3,] -0.53862610 -0.178853627 -0.46213364  0.17049174
 [4,] -0.83840536  0.369752553 -0.39035165 -2.37946865
 [5,] -0.20205208 -0.283232173  0.39724946  0.53128117
 [6,]  1.55522947 -4.062917764  0.61624559  1.51299201
 [7,] -2.41430523  1.450609825 -0.72745511  1.11472153
 [8,]  1.21757497 -1.956029594 -1.19447940  0.20468397
 [9,] -1.31708957  0.356871753  0.18974458  0.19278833
[10,]  0.41704712  1.186164554  0.45400249 -0.76360644
[11,]  0.38087854 -2.340581420 -0.05339559  0.69398683
[12,] -0.66589441  0.304060274  1.60507082  0.45630849
[13,] -0.28581867  0.953994957 -0.94587455  1.13636499
[14,] -1.05387134 -0.072719500 -1.24861143 -0.35276237
[15,] -0.28113312 -1.711288785 -0.71208989 -0.33446865
[16,] -0.75239468 -0.009961703 -0.71823546 -0.92204138
[17,]  1.40940131 -0.510906482 -0.48900589  1.20212487
[18,] -0.38641716 -1.102919045  0.07534050  0.76885912
[19,]  1.37333240  0.351440511 -1.71511359 -1.05261371
[20,]  0.39035775 -0.177079862 -1.24998658 -0.81426677
[21,]  0.73416481 -0.222998123  0.26968394  0.14806658
[22,] -0.33436913  0.175729936  0.38040977 -0.31767622
[23,]  0.02957769 -0.020381128 -0.16480255 -0.32412143
[24,]  0.25946024  0.901385566 -0.12332445  0.11335167
[25,]  0.36426394  0.437363085 -0.03264771  0.06927961
[26,]  1.46747124 -0.013422161 -0.18741037  0.26358022

[[2]]$m
[1] 26

[[2]]$Sigmuh.inv
10 x 10 sparse Matrix of class "dgCMatrix"
   [[ suppressing 10 column names 'z11', 'z12', 'z13' ... ]]
                                                      
z11  4.75 .    .    .    .    .    .    .    .    .   
z12  .    4.75 .    .    .    .    .    .    .    .   
z13  .    .    4.75 .    .    .    .    .    .    .   
z14  .    .    .    4.75 .    .    .    .    .    .   
z15  .    .    .    .    4.75 .    .    .    .    .   
z16  .    .    .    .    .    4.75 .    .    .    .   
z17  .    .    .    .    .    .    4.75 .    .    .   
z18  .    .    .    .    .    .    .    4.75 .    .   
z19  .    .    .    .    .    .    .    .    4.75 .   
z110 .    .    .    .    .    .    .    .    .    4.75


> 
> vars$nbeta <- 1
> 
> vars$p1=vars$p2=vars$p3=1/3
> 
> par<-c(6,1.5)
> del<-rep(10^-8,2)
> 
> objfun<-glmm:::objfun
> 
> umats <- clusterEvalQ(vars$cl, umatparams$umat)
> umat <- Reduce(rbind, umats)
> 
> Sigmuh.invs <- clusterEvalQ(vars$cl, umatparams$Sigmuh.inv)
> Sigmuh.inv <- Sigmuh.invs[[1]]
> Sigmuh <- solve(Sigmuh.inv)
> 
> # define a few things that will be used for finite differences
> lth<-objfun(par=par, vars=vars)
> lthdel<-objfun(par=par+del, vars=vars)
> 
> all.equal(as.vector(lth$gradient%*%del),lthdel$value-lth$value)
[1] TRUE
> all.equal(as.vector(lth$hessian%*%del),lthdel$gradient-lth$gradient)
[1] "Mean relative difference: 0.5933629"
> 
> #see exactly how big the difference is
> as.vector(lth$gradient%*%del)-(lthdel$value-lth$value)
[1] 2.195388e-13
> as.vector(lth$hessian%*%del)-(lthdel$gradient-lth$gradient)
[1]  3.403188e-08 -1.175247e-08
> 
> #we know these differences are small when we compare it to the actual values
> lthdel$value-lth$value
[1] 2.68308e-10
> as.vector(lth$gradient%*%del)
[1] 2.685276e-10
> as.vector(lth$hessian%*%del)
[1]  5.735424e-08 -1.980655e-08
> lthdel$gradient-lth$gradient
[1]  2.332236e-08 -8.054082e-09
> 
> ##########################################
> ##### to make sure that the objfun function is correct, compare it against the version without any C code. here is objfun without c:
> objfunNOC <-
+ function(par,nbeta, nu.pql,umat, u.star=u.star, mod.mcml,family.glmm, cache,gamm,p1,p2,p3, D.star, Sigmuh, zeta){
+ 
+ 	#print(par)
+ 	beta<-par[1:nbeta]
+ 	nu<-par[-(1:nbeta)]
+ 	D<-nu*diag(10)
+ 	D.inv<-(1/nu)*diag(10)
+ 	m<-nrow(umat)
+ 
+ 	if (!missing(cache)) stopifnot(is.environment(cache))
+ 	if(missing(cache)) cache<-new.env(parent = emptyenv())
+ 
+ 	if(sum(nu<=0)>0){
+ 		out<-list(value=-Inf,gradient=rep(1,length(par)),hessian=as.matrix(c(rep(1,length(par)^2)),nrow=length(par)))
+ 	return(out)
+ 	}
+ 	
+ 	Z=do.call(cbind,mod.mcml$z)
+ 
+ 	eta<-b<-rep(0,m)
+ 	lfu<-lfyu<-list(rep(c(0,0,0),m))
+ 	lfu.twid<-matrix(data=NA,nrow=m,ncol=4)
+ 
+ 	D.star.inv<-solve(D.star)
+ 	Sigmuh.inv<-solve(Sigmuh)
+ 	Dstinvdiag<-diag(D.star.inv)
+ 	tconst<-tconstant(zeta,nrow(D.star.inv),Dstinvdiag)
+ 	
+ 	#for each simulated random effect vector
+ 	for(k in 1:m){
+ 		Uk<-umat[k,]  #use the simulated vector as our random effect vec
+ 		eta<-mod.mcml$x%*%beta+Z%*%Uk # calculate eta using it
+ 		zeros<-rep(0,length(Uk))
+ 
+ 		#log f_theta(u_k)
+ 		lfu[[k]]<-distRand(nu,Uk,mod.mcml$z,zeros) 
+ 
+ 		#log f_theta(y|u_k)
+ 		lfyu[[k]]<-elR(mod.mcml$y,mod.mcml$x,eta,family.glmm) 
+ 
+ 		#log f~_theta(u_k)
+ 		lfu.twid[k,1]<-tdist2(tconst,Uk,D.star.inv,zeta=zeta,myq=nrow(D.star.inv))
+ 		lfu.twid[k,2]<-distRandGeneral(Uk,u.star,D.star.inv)
+ 		lfu.twid[k,3]<-distRandGeneral(Uk,u.star,Sigmuh.inv)
+ 		
+ 		tempmax<-max(lfu.twid[k,1:3])
+ 		blah<-exp(lfu.twid[k,1:3]-tempmax)
+ 		pea<-c(p1,p2,p3)
+ 		qux<-pea%*%blah
+ 		lfu.twid[k,4]<-tempmax+log(qux)
+ 		
+ 		b[k]<-as.numeric(lfu[[k]]$value)+as.numeric(lfyu[[k]]$value)-lfu.twid[k,4]
+ 	}
+ 
+ 	a<-max(b)
+ 	thing<-exp(b-a)
+ 	value<-a-log(m)+log(sum(thing))
+ 	v<-thing/sum(thing)
+ 	#bk are log weights
+ 	cache$weights<-exp(b)
+ 	
+ 	Gpiece<-matrix(data=NA,nrow=nrow(umat),ncol=length(par))
+ 	
+ 	#lfuky<-NA
+ 	for(k in 1:nrow(umat)){
+ 		Gpiece[k,]<-c(lfyu[[k]]$gradient,lfu[[k]]$gradient)*v[k]	
+ 		
+ 				#lfuky[k]<-c(lfyu[[k]]$gradient,lfu[[k]]$gradient)
+ 		#Gpiece[k,]<-lfuky[k]*v[k]	
+ 	}
+ 	G<-apply(Gpiece,2,sum)
+ 	
+ 	#Hessian has three pieces: panda, lobster, GGT
+ 	panda.list<-list()
+ 	for(k in 1:nrow(umat)){
+ 		panda.list[[k]]<-c(lfyu[[k]]$gradient,lfu[[k]]$gradient)%*%t(c(lfyu[[k]]$gradient,lfu[[k]]$gradient))*v[[k]]
+ 
+ 	}
+ 	panda<-addMats(panda.list)
+ 	
+ 	lobster.list<-list()
+ 	for(k in 1:nrow(umat)){
+ 
+ 		mat1<-lfyu[[k]]$hessian
+ 		mat2<-lfu[[k]]$hessian
+ 
+ 		d1<-nrow(mat1)
+ 		d2<-nrow(mat2)
+ 		newmat<-matrix(data=0,nrow=d1+d2,ncol=d1+d2)
+ 
+ 		newmat[1:d1,1:d1]<-mat1
+ 		here<-d1+1
+ 		there<-d1+d2
+ 		newmat[here:there,here:there]<-mat2	
+ 		lobster.list[[k]]<-newmat*v[k]
+ 	}
+ 	lobster<-addMats(lobster.list)
+ 	
+ 	hessian<-lobster+panda-G%*%t(G)
+ 	list(value=value,gradient=G,hessian=hessian)
+ }
> 
> #here is el without C
> elR <-
+ function(Y,X,eta,family.mcml){
+ 	family.mcml<-getFamily(family.mcml)
+ 	neta<-length(eta)
+ 
+ 	if(family.mcml$family.glmm=="bernoulli.glmm"){
+ 		foo<-.C(glmm:::C_cum3,eta=as.double(eta),neta=as.integer(neta),type=as.integer(1),ntrials=as.integer(1),cumout=double(1))$cumout
+ 		mu<-.C(glmm:::C_cp3,eta=as.double(eta),neta=as.integer(neta),type=as.integer(1),ntrials=as.integer(1),cpout=double(neta))$cpout
+ 		cdub<-.C(glmm:::C_cpp3,eta=as.double(eta),neta=as.integer(neta),type=as.integer(1),ntrials=as.integer(1),cppout=double(neta))$cppout
+ 	}
+ 	if(family.mcml$family.glmm=="poisson.glmm"){
+ 		foo<-.C(glmm:::C_cum3,eta=as.double(eta),neta=as.integer(neta),type=as.integer(2),ntrials=as.integer(1),cumout=double(1))$cumout
+ 		mu<-.C(glmm:::C_cp3,eta=as.double(eta),neta=as.integer(neta),type=as.integer(2),ntrials=as.integer(1),cpout=double(neta))$cpout
+ 		cdub<-.C(glmm:::C_cpp3,eta=as.double(eta),neta=as.integer(neta),type=as.integer(2),ntrials=as.integer(1),cppout=double(neta))$cppout
+ 	}
+ 
+ 	value<-as.numeric(Y%*%eta-foo)
+ 	gradient<-t(X)%*%(Y-mu)	
+ 	cdubmat<-diag(cdub)
+ 	hessian<-t(X)%*%(-cdubmat)%*%X
+ 	
+ 	list(value=value,gradient=gradient,hessian=hessian)
+ }
> #here are some other functions we'll need to compare objfun and objfunNOC
> getFamily<-glmm:::getFamily
> addMats<-glmm:::addMats
> tdist2<-function(tconst,u, Dstarinv,zeta,myq){
+ 	inside<-1+t(u)%*%Dstarinv%*%u/zeta
+ 	logft<-tconst - ((zeta+myq)/2)*log(inside)
+ 	as.vector(logft)
+ }
> 
> tconstant<-glmm:::tconstant
> distRandGeneral<-function(uvec,mu,Sigma.inv){
+ 	logDetSigmaInv<-sum(log(eigen(Sigma.inv,symmetric=TRUE)$values))
+ 	umu<-uvec-mu
+ 	piece2<-t(umu)%*%Sigma.inv%*%umu
+ 	out<-as.vector(.5*(logDetSigmaInv-piece2))
+ 	const<-length(uvec)*.5*log(2*pi)
+ 	out<-out-const
+ 	out
+ }
> 
> 
> distRand <-
+ function(nu,U,z.list,mu){
+ 	# T=number variance components
+ 	T<-length(z.list)
+ 	
+ 	#nrandom is q_t
+ 	nrand<-lapply(z.list,ncol)
+ 	nrandom<-unlist(nrand)
+ 	totnrandom<-sum(nrandom)
+ 	
+ 	mu.list<-U.list<-NULL
+ 	if(T==1) {
+ 		U.list[[1]]<-U
+ 		mu.list[[1]]<-mu
+ 		}
+ 
+ 	if(T>1){
+ 		U.list[[1]]<-U[1:nrandom[1]] 
+ 		mu.list[[1]]<-mu[1:nrandom[1]]
+ 		for(t in 2:T){
+ 			thing1<-sum(nrandom[1:t-1])+1
+ 			thing2<-sum(nrandom[1:t])
+ 			U.list[[t]]<-U[thing1:thing2]
+ 			mu.list[[t]]<-mu[thing1:thing2]
+ 		}
+ 	}
+ 	
+ 	val<-gradient<-Hessian<-rep(0,T)
+ 	
+ 	#for each variance component
+ 	for(t in 1:T){
+ 		you<-as.vector(U.list[[t]])
+ 		mew<-as.vector(mu.list[[t]])
+ 		Umu<-(you-mew)%*%(you-mew)
+ 		val[t]<- -length(U)*log(2*pi)/2+as.numeric(-.5*nrandom[t]*log(nu[t])-Umu/(2*nu[t]))
+ 		
+ 		gradient[t]<- -nrandom[t]/(2*nu[t])+Umu/(2*(nu[t])^2)
+ 		
+ 		Hessian[t]<- nrandom[t]/(2*(nu[t])^2)- Umu/((nu[t])^3)
+ 		
+ 	}
+ 		
+ 	value<-sum(val)
+ 	if(T>1) hessian<-diag(Hessian)
+ 	if(T==1) hessian<-matrix(Hessian,nrow=1,ncol=1)
+ 	
+ 	list(value=value,gradient=gradient,hessian=hessian)		
+ }
> 
> #finally, compare objfun and objfunNOC for B+H example
> 
> that<-objfunNOC(par=par, nbeta=1, nu.pql=vars$nu.pql, umat=umat, u.star=vars$u.star, mod.mcml=vars$mod.mcml, family.glmm=vars$family.glmm,p1=vars$p1,p2=vars$p2,p3=vars$p3, Sigmuh=Sigmuh,D.star=vars$D.star, zeta=vars$zeta)
> all.equal(that,lth)
[1] "Component \"value\": Mean relative difference: 0.0152712" 
[2] "Component \"hessian\": Mean relative difference: 1.459199"
> 
> stopCluster(clust)
> 
> proc.time()
   user  system elapsed 
 14.431   0.740  19.144 
